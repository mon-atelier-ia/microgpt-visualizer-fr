<!DOCTYPE html>
<html lang="fr" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Animations CSS — Prototypes</title>
<style>
/* ── Design tokens (simplified from app) ─────────────────────── */
:root[data-theme="dark"] {
  --bg: #181816; --surface: #23221f; --surface2: #2d2c28;
  --text: #e8e0d2; --text-dim: #959082;
  --red: #c77055; --green: #8bab7e; --blue: #7aa2f7;
  --orange: #d4976a; --cyan: #7dcfcf; --purple: #b48ead;
  --border: #3a3935; --border-hover: #55524d;
}
:root[data-theme="light"] {
  --bg: #faf8f5; --surface: #f0ede8; --surface2: #e6e3dd;
  --text: #3a3630; --text-dim: #6a655d;
  --red: #b85c42; --green: #5a8a4a; --blue: #4a7ae0;
  --orange: #c07840; --cyan: #3a9e9e; --purple: #9070a0;
  --border: #d5d0c8; --border-hover: #b5b0a8;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  background: var(--bg); color: var(--text);
  padding: 24px; max-width: 900px; margin: 0 auto;
}
h1 { font-size: 22px; margin-bottom: 6px; color: var(--orange); }
.subtitle { font-size: 12px; color: var(--text-dim); margin-bottom: 20px; }
h2 { font-size: 15px; margin: 28px 0 10px; color: var(--blue);
  border-bottom: 1px solid var(--border); padding-bottom: 4px; }
h2 span { font-size: 11px; color: var(--text-dim); font-weight: normal; margin-left: 8px; }

.controls { display: flex; gap: 8px; margin-bottom: 20px; }
.btn {
  padding: 6px 16px; border-radius: 5px; border: 1px solid var(--border-hover);
  background: var(--surface2); color: var(--text); cursor: pointer;
  font: inherit; font-size: 12px; transition: all 0.15s;
}
.btn:hover { border-color: var(--blue); }
.btn--active { background: var(--blue); color: var(--bg); border-color: var(--blue); }

.demo-box {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 16px; margin-bottom: 8px;
  min-height: 80px; position: relative; overflow: hidden;
}
.note { font-size: 11px; color: var(--text-dim); margin-bottom: 20px; }

/* ── 1. Tokenisation — slide + fade ──────────────────────────── */
.token-input {
  font-size: 18px; color: var(--text-dim); letter-spacing: 0;
  margin-bottom: 12px;
}
.token-row { display: flex; gap: 0; align-items: center; flex-wrap: wrap; }
.token-box {
  display: inline-flex; flex-direction: column; align-items: center;
  padding: 6px 10px; background: var(--surface2); border: 1px solid var(--border);
  border-radius: 5px; font-size: 14px; min-width: 32px;
  opacity: 0; transform: translateY(8px) scale(0.9);
  transition: opacity 0.3s, transform 0.3s, margin 0.3s;
  margin-right: -4px;
}
.token-box.show {
  opacity: 1; transform: translateY(0) scale(1); margin-right: 6px;
}
.token-char { color: var(--green); font-weight: bold; }
.token-id { font-size: 9px; color: var(--text-dim); margin-top: 2px; }
.token-box.bos { border-color: var(--red); }
.token-box.bos .token-char { color: var(--red); font-size: 10px; }
.token-arrow {
  color: var(--text-dim); font-size: 12px; margin: 0 -2px;
  opacity: 0; transition: opacity 0.3s 0.15s;
}
.token-arrow.show { opacity: 1; }

/* ── 2. Embedding lookup — highlight + reveal ────────────────── */
.emb-container { display: flex; gap: 16px; align-items: flex-start; }
.emb-table {
  border-collapse: collapse; font-size: 11px;
}
.emb-table td, .emb-table th {
  padding: 3px 5px; text-align: center; border: 1px solid var(--border);
  transition: background 0.3s, color 0.3s;
}
.emb-table th { color: var(--text-dim); font-weight: normal; font-size: 9px; }
.emb-table .row-label { text-align: right; color: var(--text-dim); font-size: 10px; border: none; padding-right: 8px; }
.emb-table tr.highlight td:not(.row-label) {
  background: var(--blue) !important; color: var(--bg) !important;
  font-weight: bold;
}
.emb-table tr { transition: all 0.3s; }

.emb-vector-area {
  flex: 1; display: flex; flex-direction: column; gap: 8px;
}
.emb-vector-label { font-size: 11px; color: var(--text-dim); }
.emb-vector {
  display: flex; gap: 2px; height: 28px;
}
.emb-cell {
  flex: 1; border-radius: 3px; display: flex; align-items: center; justify-content: center;
  font-size: 8px; color: var(--text);
  opacity: 0; transform: scaleX(0);
  transition: opacity 0.25s, transform 0.25s, background 0.3s;
}
.emb-cell.show { opacity: 1; transform: scaleX(1); }

/* ── 3. Loss pulse ───────────────────────────────────────────── */
.loss-grid { display: flex; gap: 6px; flex-wrap: wrap; }
.loss-cell {
  padding: 8px 10px; border-radius: 5px; font-size: 11px;
  display: flex; flex-direction: column; align-items: center; gap: 2px;
  background: var(--surface2); border: 1px solid var(--border);
  transition: border-color 0.3s;
}
.loss-cell .loss-transition { font-size: 10px; }
.loss-cell .loss-transition .from { color: var(--cyan); }
.loss-cell .loss-transition .to { color: var(--green); }
.loss-cell .loss-transition .arr { color: var(--text-dim); }
.loss-cell .loss-val { font-weight: bold; font-size: 12px; }

@keyframes pulseLow {
  0%, 100% { box-shadow: 0 0 0 0 transparent; }
  50% { box-shadow: 0 0 12px 2px rgba(139, 171, 126, 0.5); }
}
@keyframes pulseHigh {
  0%, 100% { box-shadow: 0 0 0 0 transparent; }
  50% { box-shadow: 0 0 12px 2px rgba(199, 112, 85, 0.5); }
}
.loss-cell.pulse-low {
  animation: pulseLow 0.8s ease-out;
  border-color: var(--green);
}
.loss-cell.pulse-low .loss-val { color: var(--green); }
.loss-cell.pulse-high {
  animation: pulseHigh 0.8s ease-out;
  border-color: var(--red);
}
.loss-cell.pulse-high .loss-val { color: var(--red); }

/* ── 4. Gradient descent — canvas ────────────────────────────── */
.canvas-wrap {
  position: relative; width: 100%; aspect-ratio: 2.5 / 1;
}
.canvas-wrap canvas {
  width: 100%; height: 100%; border-radius: 6px;
  background: var(--surface);
}

/* ── Reduced motion ──────────────────────────────────────────── */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}
</style>
</head>
<body>

<h1>Prototypes d'animations CSS</h1>
<p class="subtitle">4 animations manquantes pour l'app React — playground de validation visuelle</p>
<div class="controls">
  <button class="btn" id="btn-theme">Theme clair</button>
</div>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2>1. Tokenisation <span>slide + fade + espacement progressif</span></h2>
<div class="demo-box" id="demo-token">
  <div class="token-input" id="token-text">bonjour</div>
  <div class="token-row" id="token-row"></div>
</div>
<div style="display:flex;gap:8px;margin-bottom:4px;">
  <button class="btn" id="btn-tokenize">Tokeniser</button>
  <button class="btn" id="btn-token-reset">Reset</button>
  <input type="text" id="token-custom" value="bonjour" placeholder="mot..."
    style="padding:4px 10px;background:var(--surface2);border:1px solid var(--border);border-radius:5px;color:var(--text);font:inherit;font-size:12px;width:120px;">
</div>
<p class="note">Chaque caractere glisse vers le bas et s'espace — le BOS apparait en premier (rouge).</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2>2. Embedding lookup <span>highlight ligne + vecteur qui apparait</span></h2>
<div class="demo-box" id="demo-emb">
  <div class="emb-container">
    <table class="emb-table" id="emb-table"></table>
    <div class="emb-vector-area">
      <div class="emb-vector-label" id="emb-label">Clique une ligne pour voir son embedding</div>
      <div class="emb-vector" id="emb-vector"></div>
    </div>
  </div>
</div>
<p class="note">La ligne selectionnee s'illumine en bleu, puis les 8 cellules du vecteur se deploient une par une.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2>3. Loss pulse <span>rouge = loss elevee, vert = loss faible</span></h2>
<div class="demo-box" id="demo-loss">
  <div class="loss-grid" id="loss-grid"></div>
</div>
<div style="display:flex;gap:8px;margin-bottom:4px;">
  <button class="btn" id="btn-loss-step">Nouveau step</button>
</div>
<p class="note">Chaque cellule pulse — rouge si loss &gt; 2.0, vert si &lt; 1.0. Intensite proportionnelle.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2>4. Gradient descent <span>canvas — point qui descend la courbe de loss</span></h2>
<div class="demo-box" style="padding:8px;">
  <div class="canvas-wrap">
    <canvas id="gd-canvas"></canvas>
  </div>
</div>
<div style="display:flex;gap:8px;margin-bottom:4px;">
  <button class="btn" id="btn-gd-play">Descendre</button>
  <button class="btn" id="btn-gd-reset">Reset</button>
</div>
<p class="note">Le point orange suit le gradient (pente locale) et laisse une trainee. La fleche montre la direction du pas.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<script>
// ── Theme toggle ──────────────────────────────────────────────────
document.getElementById("btn-theme").addEventListener("click", function() {
  const html = document.documentElement;
  const next = html.getAttribute("data-theme") === "dark" ? "light" : "dark";
  html.setAttribute("data-theme", next);
  this.textContent = next === "dark" ? "Theme clair" : "Theme sombre";
  drawGD();
});

function getColors() {
  const s = getComputedStyle(document.documentElement);
  return {
    bg: s.getPropertyValue("--bg").trim(),
    surface: s.getPropertyValue("--surface").trim(),
    surface2: s.getPropertyValue("--surface2").trim(),
    text: s.getPropertyValue("--text").trim(),
    textDim: s.getPropertyValue("--text-dim").trim(),
    red: s.getPropertyValue("--red").trim(),
    green: s.getPropertyValue("--green").trim(),
    blue: s.getPropertyValue("--blue").trim(),
    orange: s.getPropertyValue("--orange").trim(),
    cyan: s.getPropertyValue("--cyan").trim(),
    border: s.getPropertyValue("--border").trim(),
  };
}

// ═════════════════════════════════════════════════════════════════
// 1. TOKENISATION
// ═════════════════════════════════════════════════════════════════
const VOCAB = {};
"abcdefghijklmnopqrstuvwxyz".split("").forEach((c, i) => VOCAB[c] = i + 1);
VOCAB["."] = 0; // BOS

function tokenize(word) {
  const tokens = [{ char: "BOS", id: 0, bos: true }];
  for (const c of word.toLowerCase()) {
    if (VOCAB[c] !== undefined) tokens.push({ char: c, id: VOCAB[c], bos: false });
  }
  return tokens;
}

function runTokenAnimation() {
  const word = document.getElementById("token-custom").value || "bonjour";
  document.getElementById("token-text").textContent = word;
  const row = document.getElementById("token-row");
  row.innerHTML = "";
  const tokens = tokenize(word);

  tokens.forEach((t, i) => {
    if (i > 0) {
      const arrow = document.createElement("span");
      arrow.className = "token-arrow";
      arrow.textContent = "\u2192";
      row.appendChild(arrow);
      setTimeout(() => arrow.classList.add("show"), 80 * i + 60);
    }
    const box = document.createElement("div");
    box.className = "token-box" + (t.bos ? " bos" : "");
    box.innerHTML = `<span class="token-char">${t.char}</span><span class="token-id">${t.id}</span>`;
    row.appendChild(box);
    setTimeout(() => box.classList.add("show"), 80 * i);
  });
}

document.getElementById("btn-tokenize").addEventListener("click", runTokenAnimation);
document.getElementById("btn-token-reset").addEventListener("click", () => {
  document.getElementById("token-row").innerHTML = "";
  document.getElementById("token-text").textContent = document.getElementById("token-custom").value || "bonjour";
});

// ═════════════════════════════════════════════════════════════════
// 2. EMBEDDING LOOKUP
// ═════════════════════════════════════════════════════════════════
const EMB_ROWS = 6; // show 6 tokens
const EMB_DIMS = 8; // 8 dims (simplified from 16)
const embData = [];
const embTokens = ["BOS", "a", "b", "c", "d", "e"];

for (let r = 0; r < EMB_ROWS; r++) {
  const row = [];
  for (let d = 0; d < EMB_DIMS; d++) {
    row.push(+(Math.random() * 2 - 1).toFixed(2));
  }
  embData.push(row);
}

function valToColor(v, alpha) {
  const t = (v + 1) / 2; // -1..1 -> 0..1
  const r = Math.round(199 * (1 - t) + 139 * t);
  const g = Math.round(112 * (1 - t) + 171 * t);
  const b = Math.round(85 * (1 - t) + 126 * t);
  return `rgba(${r},${g},${b},${alpha || 0.8})`;
}

function buildEmbTable() {
  const table = document.getElementById("emb-table");
  let html = "<tr><th></th>";
  for (let d = 0; d < EMB_DIMS; d++) html += `<th>d${d}</th>`;
  html += "</tr>";
  for (let r = 0; r < EMB_ROWS; r++) {
    html += `<tr data-row="${r}"><td class="row-label">${embTokens[r]}</td>`;
    for (let d = 0; d < EMB_DIMS; d++) {
      const v = embData[r][d];
      html += `<td style="background:${valToColor(v, 0.35)}">${v.toFixed(1)}</td>`;
    }
    html += "</tr>";
  }
  table.innerHTML = html;

  // Click handler
  table.querySelectorAll("tr[data-row]").forEach(tr => {
    tr.style.cursor = "pointer";
    tr.addEventListener("click", () => selectEmbRow(+tr.dataset.row));
  });
}

function selectEmbRow(rowIdx) {
  // Highlight row
  const table = document.getElementById("emb-table");
  table.querySelectorAll("tr").forEach(tr => tr.classList.remove("highlight"));
  const tr = table.querySelector(`tr[data-row="${rowIdx}"]`);
  if (tr) tr.classList.add("highlight");

  // Update label
  document.getElementById("emb-label").textContent =
    `Embedding de "${embTokens[rowIdx]}" (id=${rowIdx}) :`;

  // Animate vector cells
  const container = document.getElementById("emb-vector");
  container.innerHTML = "";
  embData[rowIdx].forEach((v, d) => {
    const cell = document.createElement("div");
    cell.className = "emb-cell";
    cell.style.background = valToColor(v, 0.7);
    cell.textContent = v.toFixed(1);
    cell.style.color = Math.abs(v) > 0.5 ? "var(--bg)" : "var(--text)";
    container.appendChild(cell);
    setTimeout(() => cell.classList.add("show"), 40 * d);
  });
}

buildEmbTable();

// ═════════════════════════════════════════════════════════════════
// 3. LOSS PULSE
// ═════════════════════════════════════════════════════════════════
const LOSS_POSITIONS = [
  { from: "b", to: "o" },
  { from: "o", to: "n" },
  { from: "n", to: "j" },
  { from: "j", to: "o" },
  { from: "o", to: "u" },
  { from: "u", to: "r" },
  { from: "r", to: "." },
];

function generateLossStep() {
  const grid = document.getElementById("loss-grid");
  grid.innerHTML = "";

  LOSS_POSITIONS.forEach((pos, i) => {
    const loss = +(Math.random() * 3.5).toFixed(2);
    const cell = document.createElement("div");
    cell.className = "loss-cell";
    cell.innerHTML = `
      <span class="loss-transition">
        <span class="from">${pos.from}</span><span class="arr"> \u2192 </span><span class="to">${pos.to}</span>
      </span>
      <span class="loss-val">${loss.toFixed(2)}</span>
    `;

    grid.appendChild(cell);

    // Trigger pulse with delay per position
    setTimeout(() => {
      if (loss > 2.0) {
        cell.classList.add("pulse-high");
        cell.style.background = `rgba(199, 112, 85, ${Math.min(loss / 5, 0.4)})`;
      } else if (loss < 1.0) {
        cell.classList.add("pulse-low");
        cell.style.background = `rgba(139, 171, 126, ${Math.min((2 - loss) / 4, 0.35)})`;
      }
    }, 60 * i);
  });
}

document.getElementById("btn-loss-step").addEventListener("click", generateLossStep);
generateLossStep();

// ═════════════════════════════════════════════════════════════════
// 4. GRADIENT DESCENT — Canvas 2D
// ═════════════════════════════════════════════════════════════════
const gdCanvas = document.getElementById("gd-canvas");
const gdCtx = gdCanvas.getContext("2d");
const dpr = window.devicePixelRatio || 1;

// Loss function: f(x) = 0.5 * (x - 0.3)^2 + 0.15 * sin(6x) + 0.8
function lossFunc(x) {
  return 0.5 * Math.pow(x - 0.3, 2) + 0.15 * Math.sin(6 * x) + 0.8;
}
function lossDeriv(x) {
  return (x - 0.3) + 0.15 * 6 * Math.cos(6 * x);
}

let gdX = 0.9;        // starting x (right side, high loss)
let gdTrail = [];      // trail of visited points
let gdAnimating = false;
let gdAnimFrame = null;

function resizeGD() {
  const rect = gdCanvas.getBoundingClientRect();
  gdCanvas.width = rect.width * dpr;
  gdCanvas.height = rect.height * dpr;
  gdCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function drawGD() {
  resizeGD();
  const c = getColors();
  const w = gdCanvas.width / dpr;
  const h = gdCanvas.height / dpr;
  const pad = { top: 20, right: 20, bottom: 30, left: 45 };
  const pw = w - pad.left - pad.right;
  const ph = h - pad.top - pad.bottom;

  // Clear
  gdCtx.clearRect(0, 0, w, h);

  // Ranges
  const xMin = -0.8, xMax = 1.2;
  const yMin = 0.4, yMax = 2.2;
  function toCanvasX(x) { return pad.left + (x - xMin) / (xMax - xMin) * pw; }
  function toCanvasY(y) { return pad.top + (1 - (y - yMin) / (yMax - yMin)) * ph; }

  // Grid
  gdCtx.strokeStyle = c.border;
  gdCtx.lineWidth = 0.5;
  for (let y = 0.5; y <= 2.0; y += 0.5) {
    const cy = toCanvasY(y);
    gdCtx.beginPath(); gdCtx.moveTo(pad.left, cy); gdCtx.lineTo(w - pad.right, cy); gdCtx.stroke();
    gdCtx.fillStyle = c.textDim; gdCtx.font = "10px monospace"; gdCtx.textAlign = "right";
    gdCtx.fillText(y.toFixed(1), pad.left - 6, cy + 3);
  }

  // Axis labels
  gdCtx.fillStyle = c.textDim; gdCtx.font = "10px monospace"; gdCtx.textAlign = "center";
  gdCtx.fillText("parametre", w / 2, h - 4);
  gdCtx.save();
  gdCtx.translate(10, h / 2);
  gdCtx.rotate(-Math.PI / 2);
  gdCtx.fillText("loss", 0, 0);
  gdCtx.restore();

  // Loss curve
  gdCtx.beginPath();
  gdCtx.strokeStyle = c.blue;
  gdCtx.lineWidth = 2;
  for (let px = 0; px <= pw; px++) {
    const x = xMin + (px / pw) * (xMax - xMin);
    const y = lossFunc(x);
    const cx = toCanvasX(x), cy = toCanvasY(y);
    if (px === 0) gdCtx.moveTo(cx, cy); else gdCtx.lineTo(cx, cy);
  }
  gdCtx.stroke();

  // Curve label
  gdCtx.fillStyle = c.blue; gdCtx.font = "11px monospace"; gdCtx.textAlign = "left";
  gdCtx.fillText("L(w)", toCanvasX(xMax) - 30, toCanvasY(lossFunc(xMax)) - 8);

  // Random baseline (dashed)
  gdCtx.setLineDash([4, 4]);
  gdCtx.strokeStyle = c.red;
  gdCtx.lineWidth = 1;
  const baseY = toCanvasY(lossFunc(0.9));
  gdCtx.beginPath(); gdCtx.moveTo(pad.left, baseY); gdCtx.lineTo(w - pad.right, baseY); gdCtx.stroke();
  gdCtx.setLineDash([]);
  gdCtx.fillStyle = c.red; gdCtx.font = "9px monospace"; gdCtx.textAlign = "right";
  gdCtx.fillText("depart", w - pad.right, baseY - 4);

  // Trail
  if (gdTrail.length > 1) {
    for (let i = 1; i < gdTrail.length; i++) {
      const alpha = 0.15 + 0.6 * (i / gdTrail.length);
      const p = gdTrail[i];
      const pp = gdTrail[i - 1];
      gdCtx.strokeStyle = `rgba(${hexToRgb(c.orange)},${alpha})`;
      gdCtx.lineWidth = 1.5;
      gdCtx.beginPath();
      gdCtx.moveTo(toCanvasX(pp.x), toCanvasY(pp.y));
      gdCtx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
      gdCtx.stroke();
    }
    // Trail dots
    gdTrail.forEach((p, i) => {
      const alpha = 0.2 + 0.6 * (i / gdTrail.length);
      const r = i === gdTrail.length - 1 ? 4 : 2;
      gdCtx.beginPath();
      gdCtx.arc(toCanvasX(p.x), toCanvasY(p.y), r, 0, Math.PI * 2);
      gdCtx.fillStyle = `rgba(${hexToRgb(c.orange)},${alpha})`;
      gdCtx.fill();
    });
  }

  // Current point (big orange dot)
  const curY = lossFunc(gdX);
  const cx = toCanvasX(gdX), cy = toCanvasY(curY);

  // Glow
  gdCtx.beginPath();
  gdCtx.arc(cx, cy, 10, 0, Math.PI * 2);
  gdCtx.fillStyle = `rgba(${hexToRgb(c.orange)}, 0.2)`;
  gdCtx.fill();

  // Dot
  gdCtx.beginPath();
  gdCtx.arc(cx, cy, 5, 0, Math.PI * 2);
  gdCtx.fillStyle = c.orange;
  gdCtx.fill();
  gdCtx.strokeStyle = c.text;
  gdCtx.lineWidth = 1;
  gdCtx.stroke();

  // Gradient arrow (tangent line)
  const grad = lossDeriv(gdX);
  const arrowLen = 30;
  const angle = Math.atan2(grad, 1); // dy/dx in screen coords (inverted y)
  // Arrow points in -gradient direction (descent)
  const dx = -Math.cos(angle) * arrowLen;
  const dy = Math.sin(angle) * arrowLen; // inverted because canvas y is down
  gdCtx.beginPath();
  gdCtx.moveTo(cx, cy);
  gdCtx.lineTo(cx + dx, cy + dy);
  gdCtx.strokeStyle = c.green;
  gdCtx.lineWidth = 2;
  gdCtx.stroke();

  // Arrowhead
  const headLen = 6;
  const headAngle = Math.atan2(dy, dx);
  gdCtx.beginPath();
  gdCtx.moveTo(cx + dx, cy + dy);
  gdCtx.lineTo(cx + dx - headLen * Math.cos(headAngle - 0.4), cy + dy - headLen * Math.sin(headAngle - 0.4));
  gdCtx.moveTo(cx + dx, cy + dy);
  gdCtx.lineTo(cx + dx - headLen * Math.cos(headAngle + 0.4), cy + dy - headLen * Math.sin(headAngle + 0.4));
  gdCtx.stroke();

  // Label: current loss
  gdCtx.fillStyle = c.orange; gdCtx.font = "bold 11px monospace"; gdCtx.textAlign = "left";
  gdCtx.fillText(`loss = ${curY.toFixed(3)}`, cx + 10, cy - 8);
  gdCtx.fillStyle = c.green; gdCtx.font = "10px monospace";
  gdCtx.fillText(`grad = ${grad.toFixed(2)}`, cx + 10, cy + 6);
}

function hexToRgb(hex) {
  hex = hex.replace("#", "");
  if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
  return `${parseInt(hex.slice(0,2),16)},${parseInt(hex.slice(2,4),16)},${parseInt(hex.slice(4,6),16)}`;
}

function stepGD() {
  const lr = 0.05;
  const grad = lossDeriv(gdX);
  gdTrail.push({ x: gdX, y: lossFunc(gdX) });
  gdX -= lr * grad;
  // Clamp to range
  gdX = Math.max(-0.7, Math.min(1.1, gdX));
}

function animateGD() {
  if (!gdAnimating) return;
  stepGD();
  drawGD();
  // Stop if gradient is very small or 60 steps reached
  if (Math.abs(lossDeriv(gdX)) < 0.02 || gdTrail.length > 60) {
    gdAnimating = false;
    return;
  }
  gdAnimFrame = requestAnimationFrame(() => {
    setTimeout(animateGD, 80); // slow enough to see each step
  });
}

document.getElementById("btn-gd-play").addEventListener("click", () => {
  if (gdAnimating) return;
  gdAnimating = true;
  animateGD();
});

document.getElementById("btn-gd-reset").addEventListener("click", () => {
  gdAnimating = false;
  if (gdAnimFrame) cancelAnimationFrame(gdAnimFrame);
  gdX = 0.9;
  gdTrail = [];
  drawGD();
});

// ── Init ──────────────────────────────────────────────────────────
drawGD();
window.addEventListener("resize", () => { if (!gdAnimating) drawGD(); });

</script>
</body>
</html>
