<!DOCTYPE html>
<html lang="fr" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neural Network — Playground</title>
<style>
/* ── Theme tokens (mirror of src/styles.css) ─────────────────── */
:root,
[data-theme="dark"] {
  --bg: #181816;
  --surface: #222220;
  --surface2: #2a2a27;
  --border: #363632;
  --border-hover: #4a4a44;
  --text: #cdc8be;
  --text-dim: #959082;
  --blue: #c28b4e;
  --purple: #a08cb4;
  --cyan: #6a9f9b;
  --green: #8aaa6b;
  --red: #bf6a63;
  --orange: #c4885c;
}
[data-theme="light"] {
  --bg: #f5f1ea;
  --surface: #fffdf8;
  --surface2: #ece8e0;
  --border: #d6d0c5;
  --border-hover: #b8b2a6;
  --text: #2c2a25;
  --text-dim: #6a655d;
  --blue: #9c6b30;
  --purple: #7b5ea0;
  --cyan: #3a7d78;
  --green: #527a34;
  --red: #a04040;
  --orange: #a06830;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: "SF Mono", "Fira Code", "Consolas", monospace;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 24px;
  transition: background 0.2s, color 0.2s;
}

/* ── Page title (matches .page-title) ───────────────────────── */
h1 {
  font-size: 22px;
  color: var(--blue);
  margin-bottom: 6px;
}
.page-desc {
  font-size: 13px;
  color: var(--text-dim);
  margin-bottom: 16px;
  text-align: center;
}

/* ── Controls bar ────────────────────────────────────────────── */
.controls {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
  margin-bottom: 16px;
}

/* ── Buttons (matches .btn / .btn-secondary) ─────────────────── */
.btn {
  padding: 7px 18px;
  background: var(--blue);
  color: var(--bg);
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 12px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.15s;
}
.btn:hover { filter: brightness(1.15); }
.btn:focus-visible {
  outline: 2px solid var(--blue);
  outline-offset: 2px;
}
.btn-secondary {
  background: var(--border-hover);
  color: var(--text);
}
.btn-toggle {
  padding: 4px 10px;
  background: var(--surface2);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
}
.btn-toggle:hover { background: var(--border); color: var(--text); }

/* ── Canvas ──────────────────────────────────────────────────── */
canvas {
  border-radius: 10px;
  cursor: crosshair;
  border: 1px solid var(--border);
  background: var(--surface);
}

/* ── Info box (matches .explain) ─────────────────────────────── */
.explain {
  font-size: 12px;
  color: var(--text-dim);
  line-height: 1.7;
  margin-top: 12px;
  padding: 10px 12px;
  background: var(--surface2);
  border-radius: 6px;
  border-left: 3px solid var(--blue);
  max-width: 620px;
  text-align: left;
}
.explain b { color: var(--cyan); }
.explain .text-red { color: var(--red); }
.explain .text-green { color: var(--green); }

/* ── Reduced motion ──────────────────────────────────────────── */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}
</style>
</head>
<body>
<h1>Forward &amp; Backward</h1>
<p class="page-desc">Visualisation 3Blue1Brown — propagation avant puis rétropropagation</p>

<div class="controls">
  <button class="btn" id="btn-replay">Rejouer</button>
  <button class="btn btn-secondary" id="btn-random">Nouvelles valeurs</button>
  <button class="btn-toggle" id="btn-theme">Thème clair</button>
</div>

<canvas id="nn"></canvas>

<div class="explain">
  <b>Survole un neurone</b> pour voir ses connexions. Chaque colonne = une couche du modèle.
  <br>La couche Attention est divisée en <b>4 têtes</b> (H0–H3) de 4 dimensions chacune.
  <br><b>Forward</b> (→) : <span class="text-red">rouge = négatif</span>,
  <span class="text-green">vert = positif</span> — le modèle calcule sa prédiction.
  <br><b>Backward</b> (←) : <span style="color:var(--orange)">orange = gradient</span>
  — le signal d'erreur remonte pour ajuster les poids.
</div>

<script>
// ── Config ───────────────────────────────────────────────────────
const LAYERS = [16, 16, 64, 16, 27];
const LABELS = [
  "Embedding\n(16)", "Attention\n(4×4 têtes)", "MLP caché\n(64)",
  "MLP sortie\n(16)", "Logits\n(27)"
];
const ANIM_LAYER_DELAY = 350;
const ANIM_FADE_DURATION = 300;

// ── Animation phases ─────────────────────────────────────────────
// "idle" → "forward" → "pause" → "backward" → "idle"
const PAUSE_DURATION = 500;

// ── State ────────────────────────────────────────────────────────
let activations = [];
let gradients = [];   // simulated backward gradients
let neurons = [];
let hoverNeuron = null;
let animStart = 0;
let animPhase = "idle"; // "idle" | "forward" | "pause" | "backward"
let dpr = 1;

const canvas = document.getElementById("nn");
const ctx = canvas.getContext("2d");

// ── Architecture constants ────────────────────────────────────────
const N_HEAD = 4;
const HEAD_DIM = 4; // 16 / 4
const ATTN_LAYER = 1; // index of attention column
const MLP_LAYER = 2;  // index of MLP hidden column

// ── Read CSS custom properties for theme-reactive canvas ─────────
function getThemeColors() {
  const s = getComputedStyle(document.documentElement);
  return {
    bg:      s.getPropertyValue("--surface").trim(),
    text:    s.getPropertyValue("--text").trim(),
    textDim: s.getPropertyValue("--text-dim").trim(),
    blue:    s.getPropertyValue("--blue").trim(),
    purple:  s.getPropertyValue("--purple").trim(),
    green:   s.getPropertyValue("--green").trim(),
    red:     s.getPropertyValue("--red").trim(),
    orange:  s.getPropertyValue("--orange").trim(),
    border:  s.getPropertyValue("--border").trim(),
  };
}

// Parse "rgb(r,g,b)" or "#rrggbb" to [r,g,b]
function parseColor(c) {
  if (c.startsWith("#")) {
    const hex = c.slice(1);
    return [
      parseInt(hex.slice(0, 2), 16),
      parseInt(hex.slice(2, 4), 16),
      parseInt(hex.slice(4, 6), 16),
    ];
  }
  const m = c.match(/(\d+)/g);
  return m ? m.map(Number) : [128, 128, 128];
}

// ── Sizing ───────────────────────────────────────────────────────
function resize() {
  dpr = window.devicePixelRatio || 1;
  const w = Math.min(window.innerWidth - 48, 960);
  const h = Math.min(window.innerHeight - 220, 580);
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  computePositions(w, h);
  draw();
}

// ── Random activations & gradients ───────────────────────────────
function randomActivations() {
  activations = LAYERS.map(n =>
    Array.from({ length: n }, () => Math.random() * 2 - 1)
  );
  activations[2] = activations[2].map(v => Math.max(0, v));

  // Simulated gradients: larger near output, smaller near input
  gradients = LAYERS.map((n, li) => {
    const scale = (li + 1) / LAYERS.length; // gradient vanishing effect
    return Array.from({ length: n }, () => (Math.random() * 2 - 1) * scale);
  });
}

// ── Compute neuron positions ─────────────────────────────────────
function computePositions(w, h) {
  const padX = 70;
  const padY = 36;
  const usableW = w - padX * 2;
  const usableH = h - padY * 2 - 30;
  const nLayers = LAYERS.length;

  neurons = LAYERS.map((count, li) => {
    const x = padX + (li / (nLayers - 1)) * usableW;
    const maxR = count <= 20 ? 7 : count <= 30 ? 5 : 3;

    // Attention layer: 4 groups of 4 with gaps between heads
    if (li === ATTN_LAYER) {
      const headGap = maxR * 2.5;  // gap between head groups
      const spacing = Math.min(usableH / (count + N_HEAD), maxR * 3.5);
      const totalH = spacing * (count - 1) + headGap * (N_HEAD - 1);
      const startY = padY + (usableH - totalH) / 2;

      return Array.from({ length: count }, (_, ni) => {
        const headIndex = Math.floor(ni / HEAD_DIM);
        const gapOffset = headIndex * headGap;
        return {
          x,
          y: startY + ni * spacing + gapOffset,
          r: maxR,
          head: headIndex,  // track which head this neuron belongs to
        };
      });
    }

    const spacing = Math.min(usableH / (count + 1), maxR * 3.5);
    const totalH = spacing * (count - 1);
    const startY = padY + (usableH - totalH) / 2;

    return Array.from({ length: count }, (_, ni) => ({
      x,
      y: startY + ni * spacing,
      r: maxR,
    }));
  });
}

// ── Color from activation value ──────────────────────────────────
function valToColor(v, alpha = 1) {
  const t = Math.max(-1, Math.min(1, v));
  const colors = getThemeColors();
  const neg = parseColor(colors.red);
  const pos = parseColor(colors.green);
  const neutral = parseColor(colors.bg);

  let r, g, b;
  if (t < 0) {
    const a = -t;
    r = Math.round(neutral[0] * (1 - a) + neg[0] * a);
    g = Math.round(neutral[1] * (1 - a) + neg[1] * a);
    b = Math.round(neutral[2] * (1 - a) + neg[2] * a);
  } else {
    const a = t;
    r = Math.round(neutral[0] * (1 - a) + pos[0] * a);
    g = Math.round(neutral[1] * (1 - a) + pos[1] * a);
    b = Math.round(neutral[2] * (1 - a) + pos[2] * a);
  }
  return `rgba(${r},${g},${b},${alpha})`;
}

// ── Animation timing ─────────────────────────────────────────────
const forwardDuration = (LAYERS.length - 1) * ANIM_LAYER_DELAY + ANIM_FADE_DURATION;
const backwardDuration = forwardDuration; // symmetric

// Forward progress per layer [0..1] — left to right
function forwardProgress(layerIndex, elapsed) {
  const layerStart = layerIndex * ANIM_LAYER_DELAY;
  return Math.max(0, Math.min(1, (elapsed - layerStart) / ANIM_FADE_DURATION));
}

// Backward progress per layer [0..1] — right to left
function backwardProgress(layerIndex, elapsed) {
  const reversedIndex = (LAYERS.length - 1) - layerIndex;
  const layerStart = reversedIndex * ANIM_LAYER_DELAY;
  return Math.max(0, Math.min(1, (elapsed - layerStart) / ANIM_FADE_DURATION));
}

// Gradient color: orange-based intensity
function gradToColor(v, alpha, colors) {
  const t = Math.min(1, Math.abs(v));
  const orangeRgb = parseColor(colors.orange);
  const neutral = parseColor(colors.bg);
  const r = Math.round(neutral[0] * (1 - t) + orangeRgb[0] * t);
  const g = Math.round(neutral[1] * (1 - t) + orangeRgb[1] * t);
  const b = Math.round(neutral[2] * (1 - t) + orangeRgb[2] * t);
  return `rgba(${r},${g},${b},${alpha})`;
}

// ── Draw ─────────────────────────────────────────────────────────
function draw(timestamp) {
  const now = timestamp || performance.now();
  const elapsed = now - animStart;
  const w = canvas.width / dpr;
  const h = canvas.height / dpr;
  const colors = getThemeColors();
  const textRgb = parseColor(colors.text);
  const orangeRgb = parseColor(colors.orange);

  // Phase transitions
  if (animPhase === "forward" && elapsed > forwardDuration + 100) {
    animPhase = "pause";
    animStart = now; // reset timer for pause
  } else if (animPhase === "pause" && elapsed > PAUSE_DURATION) {
    animPhase = "backward";
    animStart = now; // reset timer for backward
  } else if (animPhase === "backward" && elapsed > backwardDuration + 200) {
    animPhase = "idle";
  }

  // Compute per-layer progress for each phase
  const fwdElapsed = animPhase === "forward" ? elapsed : (animPhase === "idle" ? Infinity : Infinity);
  const bwdElapsed = animPhase === "backward" ? elapsed : -Infinity;

  function fwdP(li) {
    if (animPhase === "idle" || animPhase === "pause" || animPhase === "backward") return 1;
    return forwardProgress(li, elapsed);
  }
  function bwdP(li) {
    if (animPhase !== "backward") return animPhase === "idle" ? 0 : 0;
    return backwardProgress(li, elapsed);
  }

  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = colors.bg;
  ctx.fillRect(0, 0, w, h);

  // ── Phase indicator ───────────────────────────────────────────
  if (animPhase !== "idle") {
    ctx.font = "bold 13px 'SF Mono', 'Fira Code', monospace";
    ctx.textAlign = "center";
    if (animPhase === "forward") {
      ctx.fillStyle = colors.green;
      ctx.fillText("→  Propagation avant (forward)", w / 2, 18);
    } else if (animPhase === "pause") {
      ctx.fillStyle = colors.textDim;
      ctx.fillText("⋯  Calcul de l'erreur", w / 2, 18);
    } else if (animPhase === "backward") {
      ctx.fillStyle = colors.orange;
      ctx.fillText("←  Rétropropagation (backward)", w / 2, 18);
    }
  }

  // ── Draw connections ──────────────────────────────────────────
  for (let li = 0; li < LAYERS.length - 1; li++) {
    const fromLayer = neurons[li];
    const toLayer = neurons[li + 1];

    // Forward connections (left to right)
    const fwdConn = Math.min(fwdP(li), fwdP(li + 1));
    // Backward connections (right to left)
    const bwdConn = Math.min(bwdP(li), bwdP(li + 1));

    for (let fi = 0; fi < fromLayer.length; fi++) {
      for (let ti = 0; ti < toLayer.length; ti++) {
        const from = fromLayer[fi];
        const to = toLayer[ti];

        // Base forward alpha
        let alpha = 0.06 * fwdConn;
        let lineWidth = 0.5;
        let useColor = `rgba(${textRgb[0]},${textRgb[1]},${textRgb[2]},`;

        // Hover highlight
        if (hoverNeuron) {
          const hl = hoverNeuron.layer;
          const hi = hoverNeuron.index;
          const isFrom = hl === li && hi === fi;
          const isTo = hl === li + 1 && hi === ti;

          if (isFrom || isTo) {
            alpha = 0.4 * fwdConn;
            lineWidth = 1.2;
          } else if (hl === ATTN_LAYER) {
            const hoveredHead = Math.floor(hi / HEAD_DIM);
            if (li === ATTN_LAYER && Math.floor(fi / HEAD_DIM) === hoveredHead) {
              alpha = 0.15 * fwdConn;
              lineWidth = 0.8;
            } else if (li + 1 === ATTN_LAYER && Math.floor(ti / HEAD_DIM) === hoveredHead) {
              alpha = 0.15 * fwdConn;
              lineWidth = 0.8;
            }
          }
        }

        // Draw forward connection
        if (fwdConn > 0 && alpha > 0.01) {
          if (hoverNeuron &&
            ((hoverNeuron.layer === li && hoverNeuron.index === fi) ||
             (hoverNeuron.layer === li + 1 && hoverNeuron.index === ti))) {
            const fromVal = activations[li][fi];
            const toVal = activations[li + 1][ti];
            ctx.strokeStyle = valToColor((fromVal + toVal) / 2, alpha);
          } else {
            ctx.strokeStyle = `${useColor}${alpha})`;
          }
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
        }

        // Draw backward connection (orange overlay)
        if (bwdConn > 0) {
          const gradMag = (Math.abs(gradients[li][fi]) + Math.abs(gradients[li + 1][ti])) / 2;
          const bwdAlpha = 0.08 * bwdConn * (0.3 + gradMag * 0.7);
          if (bwdAlpha > 0.01) {
            ctx.strokeStyle = `rgba(${orangeRgb[0]},${orangeRgb[1]},${orangeRgb[2]},${bwdAlpha})`;
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
          }
        }
      }
    }
  }

  // ── Draw neurons ──────────────────────────────────────────────
  for (let li = 0; li < LAYERS.length; li++) {
    const fP = fwdP(li);
    const bP = bwdP(li);
    const layer = neurons[li];

    for (let ni = 0; ni < layer.length; ni++) {
      const n = layer[ni];
      const val = activations[li][ni];
      const grad = gradients[li] ? gradients[li][ni] : 0;

      // Forward glow
      if (fP > 0.5 && fP < 1 && Math.abs(val) > 0.3) {
        const glowAlpha = (1 - Math.abs(fP - 0.75) * 4) * 0.3;
        if (glowAlpha > 0) {
          ctx.beginPath();
          ctx.arc(n.x, n.y, n.r * 2.5, 0, Math.PI * 2);
          ctx.fillStyle = valToColor(val, glowAlpha);
          ctx.fill();
        }
      }

      // Backward glow (orange)
      if (bP > 0.3 && bP < 1 && Math.abs(grad) > 0.2) {
        const glowAlpha = (1 - Math.abs(bP - 0.65) * 3) * 0.35 * Math.abs(grad);
        if (glowAlpha > 0) {
          ctx.beginPath();
          ctx.arc(n.x, n.y, n.r * 2.8, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${orangeRgb[0]},${orangeRgb[1]},${orangeRgb[2]},${glowAlpha})`;
          ctx.fill();
        }
      }

      // Neuron circle — forward fill
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
      const fillAlpha = fP * 0.85;
      ctx.fillStyle = Math.abs(val) < 0.05
        ? `rgba(${textRgb[0]},${textRgb[1]},${textRgb[2]},${fillAlpha * 0.15})`
        : valToColor(val, fillAlpha);
      ctx.fill();

      // Stroke — purple for attention, default otherwise
      const strokeAlpha = 0.3 + fP * 0.4;
      const isHovered = hoverNeuron && hoverNeuron.layer === li && hoverNeuron.index === ni;
      const isAttnNeuron = li === ATTN_LAYER;
      if (isHovered) {
        ctx.strokeStyle = colors.blue;
        ctx.lineWidth = 2;
      } else if (isAttnNeuron) {
        const purpleRgb = parseColor(colors.purple);
        ctx.strokeStyle = `rgba(${purpleRgb[0]},${purpleRgb[1]},${purpleRgb[2]},${strokeAlpha})`;
        ctx.lineWidth = 1;
      } else {
        ctx.strokeStyle = `rgba(${textRgb[0]},${textRgb[1]},${textRgb[2]},${strokeAlpha})`;
        ctx.lineWidth = 1;
      }
      ctx.stroke();

      // Backward ring (orange outer ring proportional to gradient magnitude)
      if (bP > 0) {
        const ringAlpha = bP * 0.8 * Math.min(1, Math.abs(grad) + 0.2);
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r + 2, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${orangeRgb[0]},${orangeRgb[1]},${orangeRgb[2]},${ringAlpha})`;
        ctx.lineWidth = 1.5 + Math.abs(grad) * 1.5;
        ctx.stroke();
      }
    }
  }

  // ── Draw attention head brackets (H0–H3) ──────────────────────
  {
    const attnLayer = neurons[ATTN_LAYER];
    if (attnLayer && attnLayer.length === 16) {
      const bracketAlpha = fwdP(ATTN_LAYER) * 0.6;
      const bracketX = attnLayer[0].x + attnLayer[0].r + 8;
      const bracketW = 5;

      ctx.font = "9px 'SF Mono', 'Fira Code', monospace";
      ctx.textAlign = "left";

      for (let hp = 0; hp < N_HEAD; hp++) {
        const first = attnLayer[hp * HEAD_DIM];
        const last  = attnLayer[hp * HEAD_DIM + HEAD_DIM - 1];
        const top = first.y - first.r;
        const bot = last.y + last.r;
        const midY = (top + bot) / 2;

        ctx.strokeStyle = colors.purple;
        ctx.globalAlpha = bracketAlpha;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(bracketX, top);
        ctx.lineTo(bracketX + bracketW, top);
        ctx.lineTo(bracketX + bracketW, bot);
        ctx.lineTo(bracketX, bot);
        ctx.stroke();

        ctx.fillStyle = colors.purple;
        ctx.fillText("H" + hp, bracketX + bracketW + 3, midY + 3);
        ctx.globalAlpha = 1;
      }
    }
  }

  // ── Draw labels ───────────────────────────────────────────────
  ctx.textAlign = "center";
  ctx.font = "11px 'SF Mono', 'Fira Code', monospace";
  const labelY = (canvas.height / dpr) - 12;
  for (let li = 0; li < LAYERS.length; li++) {
    const x = neurons[li][0].x;
    const lines = LABELS[li].split("\n");
    lines.forEach((line, i) => {
      ctx.fillStyle = i === 0 ? colors.text : colors.textDim;
      ctx.fillText(line, x, labelY + i * 14 - (lines.length - 1) * 7);
    });
  }

  // ── Continue animation ────────────────────────────────────────
  if (animPhase !== "idle") {
    requestAnimationFrame(draw);
  }
}

// ── Hover detection ──────────────────────────────────────────────
canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let closest = null;
  let closestDist = Infinity;

  for (let li = 0; li < neurons.length; li++) {
    for (let ni = 0; ni < neurons[li].length; ni++) {
      const n = neurons[li][ni];
      const dx = mx - n.x;
      const dy = my - n.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < n.r * 3 && dist < closestDist) {
        closest = { layer: li, index: ni };
        closestDist = dist;
      }
    }
  }

  const changed = JSON.stringify(closest) !== JSON.stringify(hoverNeuron);
  hoverNeuron = closest;
  if (changed && animPhase === "idle") draw();
});

canvas.addEventListener("mouseleave", () => {
  hoverNeuron = null;
  if (animPhase === "idle") draw();
});

// ── Animation trigger ────────────────────────────────────────────
function startAnimation() {
  animStart = performance.now();
  animPhase = "forward";
  requestAnimationFrame(draw);
}

// ── Theme toggle ─────────────────────────────────────────────────
const btnTheme = document.getElementById("btn-theme");
btnTheme.addEventListener("click", () => {
  const html = document.documentElement;
  const next = html.getAttribute("data-theme") === "dark" ? "light" : "dark";
  html.setAttribute("data-theme", next);
  btnTheme.textContent = next === "dark" ? "Thème clair" : "Thème sombre";
  draw();
});

// ── Buttons ──────────────────────────────────────────────────────
document.getElementById("btn-replay").addEventListener("click", startAnimation);
document.getElementById("btn-random").addEventListener("click", () => {
  randomActivations();
  startAnimation();
});

// ── Init ─────────────────────────────────────────────────────────
randomActivations();
resize();
startAnimation();
window.addEventListener("resize", resize);
</script>
</body>
</html>
